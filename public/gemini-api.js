// Gemini API Client
class GeminiAPIClient {
    constructor() {
        this.apiKey = this.getApiKey();
        this.baseURL = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent';
        this.rateLimiter = new Map();
    }

    getApiKey() {
        // In production, this would come from environment variables
        // For client-side apps, consider using a proxy server to hide the API key
        const storedKey = localStorage.getItem('gemini_api_key');
        return storedKey || 'your_gemini_api_key';
    }

    setApiKey(apiKey) {
        this.apiKey = apiKey;
        localStorage.setItem('gemini_api_key', apiKey);
    }

    // Rate limiting check
    checkRateLimit(userId = 'default') {
        const now = Date.now();
        const userLimits = this.rateLimiter.get(userId) || { requests: [], lastReset: now };
        
        // Reset if it's been an hour
        if (now - userLimits.lastReset > 3600000) {
            userLimits.requests = [];
            userLimits.lastReset = now;
        }
        
        // Remove requests older than 1 minute
        userLimits.requests = userLimits.requests.filter(time => now - time < 60000);
        
        // Check limits (10 per minute, 500 per hour)
        const requestsInLastMinute = userLimits.requests.filter(time => now - time < 60000).length;
        const requestsInLastHour = userLimits.requests.length;
        
        if (requestsInLastMinute >= 10) {
            throw new Error('Rate limit exceeded: Too many requests per minute');
        }
        
        if (requestsInLastHour >= 500) {
            throw new Error('Rate limit exceeded: Too many requests per hour');
        }
        
        userLimits.requests.push(now);
        this.rateLimiter.set(userId, userLimits);
    }

    // Generate content using Gemini API
    async generateContent(prompt, options = {}) {
        try {
            this.checkRateLimit(options.userId);

            if (!this.apiKey || this.apiKey === 'your_gemini_api_key') {
                throw new Error('Please configure your Gemini API key in settings');
            }

            const requestBody = {
                contents: [{
                    parts: [{
                        text: this.formatPrompt(prompt, options)
                    }]
                }],
                generationConfig: {
                    temperature: this.getTemperature(options.creativityLevel),
                    maxOutputTokens: this.getMaxTokens(options.responseLength),
                    topK: 40,
                    topP: 0.95,
                }
            };

            const response = await fetch(`${this.baseURL}?key=${this.apiKey}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(requestBody)
            });

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(
                    errorData.error?.message || 
                    `API request failed with status ${response.status}`
                );
            }

            const data = await response.json();
            
            if (!data.candidates || data.candidates.length === 0) {
                throw new Error('No response generated by the model');
            }

            const content = data.candidates[0].content.parts[0].text;
            return {
                content,
                usage: data.usageMetadata || {},
                finishReason: data.candidates[0].finishReason
            };

        } catch (error) {
            console.error('Gemini API Error:', error);
            throw error;
        }
    }

    formatPrompt(prompt, options) {
        let formattedPrompt = prompt;
        
        // Add response length instruction
        if (options.responseLength) {
            const lengthInstructions = {
                'short': 'Please provide a concise response in 1-2 paragraphs.',
                'medium': 'Please provide a detailed response in 3-5 paragraphs.',
                'long': 'Please provide a comprehensive response with detailed explanations.'
            };
            formattedPrompt = lengthInstructions[options.responseLength] + '\n\n' + formattedPrompt;
        }

        return formattedPrompt;
    }

    getTemperature(creativityLevel) {
        const temperatures = {
            'conservative': 0.2,
            'balanced': 0.7,
            'creative': 0.9
        };
        return temperatures[creativityLevel] || 0.7;
    }

    getMaxTokens(responseLength) {
        const maxTokens = {
            'short': 500,
            'medium': 1000,
            'long': 2000
        };
        return maxTokens[responseLength] || 1000;
    }

    // Test API connection
    async testConnection() {
        try {
            const response = await this.generateContent('Hello, please respond with "Connection successful"', {
                responseLength: 'short',
                creativityLevel: 'conservative'
            });
            return {
                success: true,
                message: 'Connection successful',
                response: response.content
            };
        } catch (error) {
            return {
                success: false,
                message: error.message,
                error: error
            };
        }
    }

    // Get usage statistics
    getUserStats(userId = 'default') {
        const userLimits = this.rateLimiter.get(userId) || { requests: [], lastReset: Date.now() };
        const now = Date.now();
        
        const requestsInLastMinute = userLimits.requests.filter(time => now - time < 60000).length;
        const requestsInLastHour = userLimits.requests.filter(time => now - time < 3600000).length;
        
        return {
            requestsThisMinute: requestsInLastMinute,
            requestsThisHour: requestsInLastHour,
            minuteLimit: 10,
            hourlyLimit: 500
        };
    }
}

// History Manager
class PromptHistoryManager {
    constructor() {
        this.storageKey = 'gemini_prompt_history';
        this.maxHistoryItems = 100;
    }

    savePrompt(prompt, response, options = {}) {
        try {
            const history = this.getHistory();
            const newItem = {
                id: Date.now().toString(),
                prompt: prompt.substring(0, 200), // Truncate for storage
                response: response.substring(0, 500), // Truncate for storage
                fullResponse: response,
                options,
                timestamp: new Date().toISOString(),
                title: this.generateTitle(prompt)
            };

            history.unshift(newItem);

            // Keep only the latest items
            if (history.length > this.maxHistoryItems) {
                history.splice(this.maxHistoryItems);
            }

            localStorage.setItem(this.storageKey, JSON.stringify(history));
        } catch (error) {
            console.error('Failed to save prompt history:', error);
        }
    }

    getHistory() {
        try {
            const stored = localStorage.getItem(this.storageKey);
            return stored ? JSON.parse(stored) : [];
        } catch (error) {
            console.error('Failed to load prompt history:', error);
            return [];
        }
    }

    getRecentPrompts(limit = 10) {
        return this.getHistory().slice(0, limit);
    }

    generateTitle(prompt) {
        const words = prompt.split(' ').slice(0, 6);
        let title = words.join(' ');
        if (prompt.split(' ').length > 6) {
            title += '...';
        }
        return title || 'Untitled Prompt';
    }

    deletePrompt(id) {
        try {
            const history = this.getHistory().filter(item => item.id !== id);
            localStorage.setItem(this.storageKey, JSON.stringify(history));
        } catch (error) {
            console.error('Failed to delete prompt:', error);
        }
    }

    clearHistory() {
        try {
            localStorage.removeItem(this.storageKey);
        } catch (error) {
            console.error('Failed to clear history:', error);
        }
    }
}

// Initialize global instances
window.geminiAPI = new GeminiAPIClient();
window.promptHistory = new PromptHistoryManager();